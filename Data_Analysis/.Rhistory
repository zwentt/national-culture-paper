deviance = as.numeric(logLik(currentModel.fit))*-2,
para_count = attr(logLik(currentModel.fit), "df"),
sigularity = isSingular(currentModel.fit, tol = .00000000001),
convWarning = MdlSUM$optinfo$conv$opt,
aic = AIC(currentModel.fit),
bic = BIC(currentModel.fit),
group_count = as.numeric(summary(currentModel.fit)$ngrps),
firm_count = nobs(currentModel.fit)
)
#Initialize a dataframe to contain all the estimates from the loop
if (counter == 1)
cross_estimates <- estimates
else
cross_estimates <- rbind(cross_estimates, estimates)
counter <- counter + 1
}
t.a.cross <- t(cross_estimates)
colnames(t.a.cross) <- cross_estimates[,1]
write.csv(t.a.cross, paste(filepath, "estimates.a.cross.csv", sep=""), row.names = TRUE)
#======================== Agility and Culture - Outcome Model ==========================
#1. outcome Control Variable Only Models
counter <- 1
#Empty container if necessary
rm(o.controlVar_estimates)
for (dv in outcomeMeasures) {
vars <- c("firmsizestd", "gmci2016c", "I(firmsizestd*firmsizestd)", "(1 | countryx)")
vars_incld <- ""
for (var in vars) {
vars_incld <- paste(vars_incld, var, sep = " + ")
}
vars_incld <- substr(vars_incld, 4, 4000)
o.controlVarModel <- eval(paste(dv, " ~ ", vars_incld, sep = ""))
currentModel <- o.controlVarModel
currentModel.fit <- blmer(currentModel, data = CultureData, REML = FALSE,
control=lmerControl(optimizer="Nelder_Mead", optCtrl=list(maxfun = 1e+05)), verbose = TRUE)
print(summary(currentModel.fit))
MdlSUM  <- summary(currentModel.fit)
COEF    <- round(summary(currentModel.fit)$coefficients, 4)
VAR     <- round(as.data.frame(VarCorr(currentModel.fit))["vcov"], 4)
MdlINFO <- round(as.data.frame(logLik(currentModel.fit)*-2, 4))
estimates <- data.frame(
model_name = paste("o.ControlVar_", dv, sep =" "),
dv = dv,
intercept = COEF["(Intercept)", "Estimate"],
intercept_se = COEF["(Intercept)", "Std. Error"],
intercept_t = COEF["(Intercept)", "t value"],
intercept_sig = sigStar(COEF["(Intercept)", "t value"]),
firmsizestd = COEF["firmsizestd", "Estimate"],
firmsizestd_se = COEF["firmsizestd", "Std. Error"],
firmsizestd_t = COEF["firmsizestd", "t value"],
firmsizestd_sig = sigStar(COEF["firmsizestd", "t value"]),
gmci2016c = COEF["gmci2016c", "Estimate"],
gmci2016c_se = COEF["gmci2016c", "Std. Error"],
gmci2016c_t = COEF["gmci2016c", "t value"],
gmci2016c_sig = sigStar(COEF["gmci2016c", "t value"]),
firmsize_sq = COEF["I(firmsizestd * firmsizestd)", "Estimate"],
firmsize_sq_se = COEF["I(firmsizestd * firmsizestd)", "Std. Error"],
firmsize_sq_t = COEF["I(firmsizestd * firmsizestd)", "t value"],
firmsize_sq_sig = sigStar(COEF["I(firmsizestd * firmsizestd)", "t value"]),
var_firm = VAR[2, 1],
var_country = VAR[1,1],
deviance = as.numeric(logLik(currentModel.fit))*-2,
para_count = attr(logLik(currentModel.fit), "df"),
sigularity = isSingular(currentModel.fit, tol = .00000000001),
convWarning = MdlSUM$optinfo$conv$opt,
aic = AIC(currentModel.fit),
bic = BIC(currentModel.fit),
group_count = as.numeric(summary(currentModel.fit)$ngrps),
firm_count = nobs(currentModel.fit)
)
#Initialize a dataframe to contain all the estimates from the loop
if (counter == 1)
o.controlVar_estimates <- estimates
else
o.controlVar_estimates <- rbind(o.controlVar_estimates, estimates)
counter <- counter+1
}
t.o.controlVar <- t(o.controlVar_estimates)
colnames(t.o.controlVar) <- o.controlVar_estimates[,1]
write.csv(t.o.controlVar, paste(filepath, "estimates.o.controlVar.csv", sep=""), row.names = TRUE)
#2. outcome Random Intercept Model
counter <- 1
dv <- "outcome"
#Empty estimation results when necessary
rm(o.RI_estimates)
for (varRI in glo_v) {
#variable setup
culc <- paste(varRI, "_c", sep="")
vars <- c("agility2cj", "firmsizestd", "network2xcj", "I(network2xcj*agility2cj)", "gmci2016c", "I(firmsizestd*firmsizestd)", paste("(", culc, " | country)", sep=""))
vars_incld <- ""
for (v in vars) {
vars_incld <- paste(vars_incld, v, sep = " + ")
}
vars_incld <- substr(vars_incld, 4, 4000)
o.RIModel <- eval(paste(dv, " ~ ", vars_incld, sep = ""))
currentModel <- o.RIModel
currentModel.fit <- blmer(currentModel, data = CultureData, REML = FALSE,
control=lmerControl(optimizer="Nelder_Mead", optCtrl=list(maxfun = 1e+05)), verbose = TRUE)
print(summary(currentModel.fit))
MdlSUM  <- summary(currentModel.fit)
COEF    <- round(summary(currentModel.fit)$coefficients, 4)
VAR     <- as.data.frame(VarCorr(currentModel.fit))
MdlINFO <- round(as.data.frame(logLik(currentModel.fit)*-2, 4))
estimates <- data.frame(
model_name = paste("o.RI_", culc, sep =""),
dv = dv,
cul = culc,
intercept = COEF["(Intercept)", "Estimate"],
intercept_se = COEF["(Intercept)", "Std. Error"],
intercept_t = COEF["(Intercept)", "t value"],
intercept_sig = sigStar(COEF["(Intercept)", "t value"]),
agility2cj = COEF["agility2cj", "Estimate"],
agility2cj_se = COEF["agility2cj", "Std. Error"],
agility2cj_t = COEF["agility2cj", "t value"],
agility2cj_sig = sigStar(COEF["agility2cj", "t value"]),
network2xcj = COEF["network2xcj", "Estimate"],
network2xcj_se = COEF["network2xcj", "Std. Error"],
network2xcj_t = COEF["network2xcj", "t value"],
network2xcj_sig = sigStar(COEF["network2xcj", "t value"]),
agility_network_int = COEF["I(network2xcj * agility2cj)", "Estimate"],
agility_network_int_se = COEF["I(network2xcj * agility2cj)", "Std. Error"],
agility_network_int_t = COEF["I(network2xcj * agility2cj)", "t value"],
agility_network_int_sig = sigStar(COEF["I(network2xcj * agility2cj)", "t value"]),
firmsizestd = COEF["firmsizestd", "Estimate"],
firmsizestd_se = COEF["firmsizestd", "Std. Error"],
firmsizestd_t = COEF["firmsizestd", "t value"],
firmsizestd_sig = sigStar(COEF["firmsizestd", "t value"]),
gmci2016c = COEF["gmci2016c", "Estimate"],
gmci2016c_se = COEF["gmci2016c", "Std. Error"],
gmci2016c_t = COEF["gmci2016c", "t value"],
gmci2016c_sig = sigStar(COEF["gmci2016c", "t value"]),
firmsize_sq = COEF["I(firmsizestd * firmsizestd)", "Estimate"],
firmsize_sq_se = COEF["I(firmsizestd * firmsizestd)", "Std. Error"],
firmsize_sq_t = COEF["I(firmsizestd * firmsizestd)", "t value"],
firmsize_sq_sig = sigStar(COEF["I(firmsizestd * firmsizestd)", "t value"]),
var_firm = VAR[4, "vcov"],
var_intercept = VAR[1,"vcov"],
var_culc = VAR[2,"vcov"],
cov_int_culc = VAR[3,"vcov"],
deviance = as.numeric(logLik(currentModel.fit))*-2,
para_count = attr(logLik(currentModel.fit), "df"),
sigularity = isSingular(currentModel.fit, tol = .00000000001),
convWarning = MdlSUM$optinfo$conv$opt,
aic = AIC(currentModel.fit),
bic = BIC(currentModel.fit),
group_count = as.numeric(summary(currentModel.fit)$ngrps),
firm_count = nobs(currentModel.fit)
)
#Initialize a dataframe to contain all the estimates from the loop
if (counter == 1)
o.RI_estimates <- estimates
else
o.RI_estimates <- rbind(o.RI_estimates, estimates)
counter <- counter+1
}
t.o.RI <- t(o.RI_estimates)
colnames(t.o.RI) <- o.RI_estimates[,1]
write.csv(t.o.RI, paste(filepath, "estimates.o.RI.csv", sep=""), row.names = TRUE)
#3. outcome Random Intercept and Random Slope Model
counter <- 1
dv <- "outcome"
#Empty the results container file when necessary
rm(o.RIRS_estimates)
for (varRIRS in glo_v) {
#variable setup
culc <- paste(varRIRS, "_c", sep="")
vars <- c("agility2cj", culc, "firmsizestd", "network2xcj", "I(network2xcj*agility2cj)", "gmci2016c", "I(firmsizestd*firmsizestd)", paste("(", culc, " | country)", sep=""))
vars_incld <- ""
for (v in vars) {
vars_incld <- paste(vars_incld, v, sep = " + ")
}
vars_incld <- substr(vars_incld, 4, 4000)
o.RIRSModel <- eval(paste(dv, " ~ ", vars_incld, sep = ""))
currentModel <- o.RIRSModel
currentModel.fit <- blmer(currentModel, data = CultureData, REML = FALSE,
control=lmerControl(optimizer="Nelder_Mead", optCtrl=list(maxfun = 1e+05)), verbose = TRUE)
print(summary(currentModel.fit))
MdlSUM  <- summary(currentModel.fit)
COEF    <- round(summary(currentModel.fit)$coefficients, 4)
VAR     <- as.data.frame(VarCorr(currentModel.fit))
MdlINFO <- round(as.data.frame(logLik(currentModel.fit)*-2, 4))
estimates <- data.frame(
model_name = paste("RI_", culc, sep =""),
dv = dv,
cul = culc,
intercept = COEF["(Intercept)", "Estimate"],
intercept_se = COEF["(Intercept)", "Std. Error"],
intercept_t = COEF["(Intercept)", "t value"],
intercept_sig = sigStar(COEF["(Intercept)", "t value"]),
culc = COEF[culc, "Estimate"],
culc_se = COEF[culc, "Std. Error"],
culc_t = COEF[culc, "t value"],
culc_sig = sigStar(COEF[culc, "t value"]),
agility2cj = COEF["agility2cj", "Estimate"],
agility2cj_se = COEF["agility2cj", "Std. Error"],
agility2cj_t = COEF["agility2cj", "t value"],
agility2cj_sig = sigStar(COEF["agility2cj", "t value"]),
network2xcj = COEF["network2xcj", "Estimate"],
network2xcj_se = COEF["network2xcj", "Std. Error"],
network2xcj_t = COEF["network2xcj", "t value"],
network2xcj_sig = sigStar(COEF["network2xcj", "t value"]),
agility_network_int = COEF["I(network2xcj * agility2cj)", "Estimate"],
agility_network_int_se = COEF["I(network2xcj * agility2cj)", "Std. Error"],
agility_network_int_t = COEF["I(network2xcj * agility2cj)", "t value"],
agility_network_int_sig = sigStar(COEF["I(network2xcj * agility2cj)", "t value"]),
firmsizestd = COEF["firmsizestd", "Estimate"],
firmsizestd_se = COEF["firmsizestd", "Std. Error"],
firmsizestd_t = COEF["firmsizestd", "t value"],
firmsizestd_sig = sigStar(COEF["firmsizestd", "t value"]),
gmci2016c = COEF["gmci2016c", "Estimate"],
gmci2016c_se = COEF["gmci2016c", "Std. Error"],
gmci2016c_t = COEF["gmci2016c", "t value"],
gmci2016c_sig = sigStar(COEF["gmci2016c", "t value"]),
firmsize_sq = COEF["I(firmsizestd * firmsizestd)", "Estimate"],
firmsize_sq_se = COEF["I(firmsizestd * firmsizestd)", "Std. Error"],
firmsize_sq_t = COEF["I(firmsizestd * firmsizestd)", "t value"],
firmsize_sq_sig = sigStar(COEF["I(firmsizestd * firmsizestd)", "t value"]),
var_firm = VAR[4, "vcov"],
var_intercept = VAR[1,"vcov"],
var_culc = VAR[2,"vcov"],
cov_int_culc = VAR[3,"vcov"],
deviance = as.numeric(logLik(currentModel.fit))*-2,
para_count = attr(logLik(currentModel.fit), "df"),
sigularity = isSingular(currentModel.fit, tol = .00000000001),
convWarning = MdlSUM$optinfo$conv$opt,
aic = AIC(currentModel.fit),
bic = BIC(currentModel.fit),
group_count = as.numeric(summary(currentModel.fit)$ngrps),
firm_count = nobs(currentModel.fit)
)
#Initialize a dataframe to contain all the estimates from the loop
if (counter == 1)
o.RIRS_estimates <- estimates
else
o.RIRS_estimates <- rbind(o.RIRS_estimates, estimates)
counter <- counter + 1
}
#transpose the estimates dataframe
t.o.RIRS <- t(o.RIRS_estimates)
colnames(t.o.RIRS) <- o.RIRS_estimates[,1]
write.csv(t.o.RIRS, paste(filepath, "estimates.o.RIRS.csv", sep=""), row.names = TRUE)
#4. outcome Cross Level Model
counter <- 1
dv <- "outcome"
#Empty the results container file when necessary
rm(o.cross_estimates)
for (varCross in glo_v) {
#empty the model estimates container
#if (length(slope_estimates[, 1]) >= length(glo_v))
#variable setup
culc <- paste(varCross, "_c", sep="")
vars <- c("agility2cj", culc, "firmsizestd", "network2xcj", "I(network2xcj*agility2cj)", "gmci2016c", "I(firmsizestd*firmsizestd)",
paste("I(agility2cj*", culc, ")", sep = ""),
paste("I(network2xcj*", culc, ")", sep = ""),
paste("I(network2xcj*agility2cj*", culc, ")", sep = ""),
paste("(", culc, " | country)", sep="")
)
vars_incld <- ""
for (v in vars) {
vars_incld <- paste(vars_incld, v, sep = " + ")
}
vars_incld <- substr(vars_incld, 4, 4000)
o.crossModel <- eval(paste(dv, " ~ ", vars_incld, sep = ""))
currentModel <- o.crossModel
currentModel.fit <- blmer(currentModel, data = CultureData, REML = FALSE,
control=lmerControl(optimizer="Nelder_Mead", optCtrl=list(maxfun = 1e+05)), verbose = TRUE)
print(summary(currentModel.fit))
MdlSUM  <- summary(currentModel.fit)
COEF    <- round(summary(currentModel.fit)$coefficients, 4)
VAR     <- as.data.frame(VarCorr(currentModel.fit))
MdlINFO <- round(as.data.frame(logLik(currentModel.fit)*-2, 4))
estimates <- data.frame(
model_name = paste("RI_", culc, sep =""),
dv = dv,
cul = culc,
intercept = COEF["(Intercept)", "Estimate"],
intercept_se = COEF["(Intercept)", "Std. Error"],
intercept_t = COEF["(Intercept)", "t value"],
intercept_sig = sigStar(COEF["(Intercept)", "t value"]),
culc = COEF[culc, "Estimate"],
culc_se = COEF[culc, "Std. Error"],
culc_t = COEF[culc, "t value"],
culc_sig = sigStar(COEF[culc, "t value"]),
agility2cj = COEF["agility2cj", "Estimate"],
agility2cj_se = COEF["agility2cj", "Std. Error"],
agility2cj_t = COEF["agility2cj", "t value"],
agility2cj_sig = sigStar(COEF["agility2cj", "t value"]),
network2xcj = COEF["network2xcj", "Estimate"],
network2xcj_se = COEF["network2xcj", "Std. Error"],
network2xcj_t = COEF["network2xcj", "t value"],
network2xcj_sig = sigStar(COEF["network2xcj", "t value"]),
agility_network_int = COEF["I(network2xcj * agility2cj)", "Estimate"],
agility_network_int_se = COEF["I(network2xcj * agility2cj)", "Std. Error"],
agility_network_int_t = COEF["I(network2xcj * agility2cj)", "t value"],
agility_network_int_sig = sigStar(COEF["I(network2xcj * agility2cj)", "t value"]),
firmsizestd = COEF["firmsizestd", "Estimate"],
firmsizestd_se = COEF["firmsizestd", "Std. Error"],
firmsizestd_t = COEF["firmsizestd", "t value"],
firmsizestd_sig = sigStar(COEF["firmsizestd", "t value"]),
gmci2016c = COEF["gmci2016c", "Estimate"],
gmci2016c_se = COEF["gmci2016c", "Std. Error"],
gmci2016c_t = COEF["gmci2016c", "t value"],
gmci2016c_sig = sigStar(COEF["gmci2016c", "t value"]),
firmsize_sq = COEF["I(firmsizestd * firmsizestd)", "Estimate"],
firmsize_sq_se = COEF["I(firmsizestd * firmsizestd)", "Std. Error"],
firmsize_sq_t = COEF["I(firmsizestd * firmsizestd)", "t value"],
firmsize_sq_sig = sigStar(COEF["I(firmsizestd * firmsizestd)", "t value"]),
agility_culc_int = COEF[9, "Estimate"],
agility_culc_int_se = COEF[9, "Std. Error"],
agility_culc_int_t = COEF[9, "t value"],
agility_culc_int_sig = sigStar(COEF[9, "t value"]),
network_culc_int = COEF[10, "Estimate"],
network_culc_int_se = COEF[10, "Std. Error"],
network_culc_int_t = COEF[10, "t value"],
network_culc_int_sig = sigStar(COEF[10, "t value"]),
triple_int = COEF[11, "Estimate"],
triple_int_se = COEF[11, "Std. Error"],
triple_int_t = COEF[11, "t value"],
triple_int_sig = sigStar(COEF[11, "t value"]),
var_firm = VAR[4, "vcov"],
var_intercept = VAR[1,"vcov"],
var_culc = VAR[2,"vcov"],
cov_int_culc = VAR[3,"vcov"],
deviance = as.numeric(logLik(currentModel.fit))*-2,
para_count = attr(logLik(currentModel.fit), "df"),
sigularity = isSingular(currentModel.fit, tol = .00000000001),
convWarning = MdlSUM$optinfo$conv$opt,
aic = AIC(currentModel.fit),
bic = BIC(currentModel.fit),
group_count = as.numeric(summary(currentModel.fit)$ngrps),
firm_count = nobs(currentModel.fit)
)
#Initialize a dataframe to contain all the estimates from the loop
if (counter == 1)
o.cross_estimates <- estimates
else
o.cross_estimates <- rbind(o.cross_estimates, estimates)
counter <- counter + 1
}
#transpose the estimates dataframe
t.o.cross <- t(o.cross_estimates)
colnames(t.o.cross) <- o.cross_estimates[,1]
write.csv(t.o.cross, paste(filepath, "estimates_o.cross.csv", sep=""), row.names = TRUE)
#5a. outcome Cross Level Model - domestic firms only
counter <- 1
dv <- "outcome"
#Empty the results container file when necessary
rm(o.cross_domestic_estimates)
for (varCross in glo_v) {
#empty the model estimates container
#if (length(slope_estimates[, 1]) >= length(glo_v))
#variable setup
culc <- paste(varCross, "_c", sep="")
vars <- c("agility2cj", culc, "firmsizestd", "gmci2016c", "I(firmsizestd*firmsizestd)",
paste("I(agility2cj*", culc, ")", sep = ""),
paste("(", culc, " | country)", sep="")
)
vars_incld <- ""
for (v in vars) {
vars_incld <- paste(vars_incld, v, sep = " + ")
}
vars_incld <- substr(vars_incld, 4, 4000)
o.crossModel_domestic <- eval(paste(dv, " ~ ", vars_incld, sep = ""))
currentModel <- o.crossModel_domestic
currentModel.fit <- blmer(currentModel, data = subset(CultureData, network2x == 0), REML = FALSE,
control=lmerControl(optimizer="Nelder_Mead", optCtrl=list(maxfun = 1e+05)), verbose = TRUE)
print(summary(currentModel.fit))
MdlSUM  <- summary(currentModel.fit)
COEF    <- round(summary(currentModel.fit)$coefficients, 4)
VAR     <- as.data.frame(VarCorr(currentModel.fit))
MdlINFO <- round(as.data.frame(logLik(currentModel.fit)*-2, 4))
estimates <- data.frame(
model_name = paste("RI_", culc, sep =""),
dv = dv,
cul = culc,
intercept = COEF["(Intercept)", "Estimate"],
intercept_se = COEF["(Intercept)", "Std. Error"],
intercept_t = COEF["(Intercept)", "t value"],
intercept_sig = sigStar(COEF["(Intercept)", "t value"]),
culc = COEF[culc, "Estimate"],
culc_se = COEF[culc, "Std. Error"],
culc_t = COEF[culc, "t value"],
culc_sig = sigStar(COEF[culc, "t value"]),
agility2cj = COEF["agility2cj", "Estimate"],
agility2cj_se = COEF["agility2cj", "Std. Error"],
agility2cj_t = COEF["agility2cj", "t value"],
agility2cj_sig = sigStar(COEF["agility2cj", "t value"]),
firmsizestd = COEF["firmsizestd", "Estimate"],
firmsizestd_se = COEF["firmsizestd", "Std. Error"],
firmsizestd_t = COEF["firmsizestd", "t value"],
firmsizestd_sig = sigStar(COEF["firmsizestd", "t value"]),
gmci2016c = COEF["gmci2016c", "Estimate"],
gmci2016c_se = COEF["gmci2016c", "Std. Error"],
gmci2016c_t = COEF["gmci2016c", "t value"],
gmci2016c_sig = sigStar(COEF["gmci2016c", "t value"]),
firmsize_sq = COEF["I(firmsizestd * firmsizestd)", "Estimate"],
firmsize_sq_se = COEF["I(firmsizestd * firmsizestd)", "Std. Error"],
firmsize_sq_t = COEF["I(firmsizestd * firmsizestd)", "t value"],
firmsize_sq_sig = sigStar(COEF["I(firmsizestd * firmsizestd)", "t value"]),
agility_culc_int = COEF[7, "Estimate"],
agility_culc_int_se = COEF[7, "Std. Error"],
agility_culc_int_t = COEF[7, "t value"],
agility_culc_int_sig = sigStar(COEF[7, "t value"]),
var_firm = VAR[4, "vcov"],
var_intercept = VAR[1,"vcov"],
var_culc = VAR[2,"vcov"],
cov_int_culc = VAR[3,"vcov"],
deviance = as.numeric(logLik(currentModel.fit))*-2,
para_count = attr(logLik(currentModel.fit), "df"),
sigularity = isSingular(currentModel.fit, tol = .00000000001),
convWarning = MdlSUM$optinfo$conv$opt,
aic = AIC(currentModel.fit),
bic = BIC(currentModel.fit),
group_count = as.numeric(summary(currentModel.fit)$ngrps),
firm_count = nobs(currentModel.fit)
)
#Initialize a dataframe to contain all the estimates from the loop
if (counter == 1)
o.cross_domestic_estimates <- estimates
else
o.cross_domestic_estimates <- rbind(o.cross_domestic_estimates, estimates)
counter <- counter + 1
}
#transpose the estimates dataframe
t.o.cross.domestic <- t(o.cross_domestic_estimates)
colnames(t.o.cross.domestic) <- o.cross_domestic_estimates[,1]
write.csv(t.o.cross.domestic, paste(filepath, "estimates_o.cross.domestic.csv", sep=""), row.names = TRUE)
#5b. outcome Cross Level Model - multinational firms
counter <- 1
dv <- "outcome"
#Empty the results container file when necessary
rm(o.cross_multinational_estimates)
for (varCross in glo_v) {
#empty the model estimates container
#if (length(slope_estimates[, 1]) >= length(glo_v))
#variable setup
culc <- paste(varCross, "_c", sep="")
vars <- c("agility2cj", culc, "firmsizestd", "gmci2016c", "I(firmsizestd*firmsizestd)",
paste("I(agility2cj*", culc, ")", sep = ""),
paste("(", culc, " | country)", sep="")
)
vars_incld <- ""
for (v in vars) {
vars_incld <- paste(vars_incld, v, sep = " + ")
}
vars_incld <- substr(vars_incld, 4, 4000)
o.crossModel_multinational <- eval(paste(dv, " ~ ", vars_incld, sep = ""))
currentModel <- o.crossModel_multinational
currentModel.fit <- blmer(currentModel, data = subset(CultureData, network2x == 1), REML = FALSE,
control=lmerControl(optimizer="Nelder_Mead", optCtrl=list(maxfun = 1e+05)), verbose = TRUE)
print(summary(currentModel.fit))
MdlSUM  <- summary(currentModel.fit)
COEF    <- round(summary(currentModel.fit)$coefficients, 4)
VAR     <- as.data.frame(VarCorr(currentModel.fit))
MdlINFO <- round(as.data.frame(logLik(currentModel.fit)*-2, 4))
estimates <- data.frame(
model_name = paste("RI_", culc, sep =""),
dv = dv,
cul = culc,
intercept = COEF["(Intercept)", "Estimate"],
intercept_se = COEF["(Intercept)", "Std. Error"],
intercept_t = COEF["(Intercept)", "t value"],
intercept_sig = sigStar(COEF["(Intercept)", "t value"]),
culc = COEF[culc, "Estimate"],
culc_se = COEF[culc, "Std. Error"],
culc_t = COEF[culc, "t value"],
culc_sig = sigStar(COEF[culc, "t value"]),
agility2cj = COEF["agility2cj", "Estimate"],
agility2cj_se = COEF["agility2cj", "Std. Error"],
agility2cj_t = COEF["agility2cj", "t value"],
agility2cj_sig = sigStar(COEF["agility2cj", "t value"]),
firmsizestd = COEF["firmsizestd", "Estimate"],
firmsizestd_se = COEF["firmsizestd", "Std. Error"],
firmsizestd_t = COEF["firmsizestd", "t value"],
firmsizestd_sig = sigStar(COEF["firmsizestd", "t value"]),
gmci2016c = COEF["gmci2016c", "Estimate"],
gmci2016c_se = COEF["gmci2016c", "Std. Error"],
gmci2016c_t = COEF["gmci2016c", "t value"],
gmci2016c_sig = sigStar(COEF["gmci2016c", "t value"]),
firmsize_sq = COEF["I(firmsizestd * firmsizestd)", "Estimate"],
firmsize_sq_se = COEF["I(firmsizestd * firmsizestd)", "Std. Error"],
firmsize_sq_t = COEF["I(firmsizestd * firmsizestd)", "t value"],
firmsize_sq_sig = sigStar(COEF["I(firmsizestd * firmsizestd)", "t value"]),
agility_culc_int = COEF[7, "Estimate"],
agility_culc_int_se = COEF[7, "Std. Error"],
agility_culc_int_t = COEF[7, "t value"],
agility_culc_int_sig = sigStar(COEF[7, "t value"]),
var_firm = VAR[4, "vcov"],
var_intercept = VAR[1,"vcov"],
var_culc = VAR[2,"vcov"],
cov_int_culc = VAR[3,"vcov"],
deviance = as.numeric(logLik(currentModel.fit))*-2,
para_count = attr(logLik(currentModel.fit), "df"),
sigularity = isSingular(currentModel.fit, tol = .00000000001),
convWarning = MdlSUM$optinfo$conv$opt,
aic = AIC(currentModel.fit),
bic = BIC(currentModel.fit),
group_count = as.numeric(summary(currentModel.fit)$ngrps),
firm_count = nobs(currentModel.fit)
)
#Initialize a dataframe to contain all the estimates from the loop
if (counter == 1)
o.cross_multinational_estimates <- estimates
else
o.cross_multinational_estimates <- rbind(o.cross_multinational_estimates, estimates)
counter <- counter + 1
}
#transpose the estimates dataframe
t.o.cross.multinational <- t(o.cross_multinational_estimates)
colnames(t.o.cross.multinational) <- o.cross_multinational_estimates[,1]
write.csv(t.o.cross.multinational, paste(filepath, "estimates_o.cross.multinational.csv", sep=""), row.names = TRUE)
}
